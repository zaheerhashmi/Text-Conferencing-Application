Section 2 Design:

- All clients are stored in a struct, which include the following fields.

struct registeredClients {
    char clientID[MAXBUFLEN]; // client ID
    char password[MAXBUFLEN]; // password
    int activeStatus; // Is logged in or not
    struct clientSessionID * sessionList; // list of sessions that the client is in.
    int portNumber; // client's port number (socket number)
    char clientIP[MAXBUFLEN]; // client's IP addres
};

=========================================================================================================================

1. Multiple Sessions Implementation

To implement multiple sessions, we use a linked list for each client to store the rooms
that client is in. It takes O((number of users) * (number of rooms)) to send a message
to one room or multiple rooms.

To send message to one room, we would need to go through every user and find a room that 
they're interested in.

To send message to all rooms, we would need to do the same thing.

We understand this is not the most efficient design, as if we stored every user in each 
room instead, sending message to one room would only take O(number of rooms). However,
we used this design because it makes it more straight forward for us to print
the rooms that each user is in, as shown below.

Here is a table of users and their sessions
        User -> harris , Session -> turtle,
        User -> zaheer, Session -> turtle, ice_cream

=========================================================================================================================

2. Invite Function

INVITE functionality has both server and client side functionality. 
Here are some assumptions:
    - Client can only invite clients to a session it is in by itself
    - A client may accept or deny a request 
    - The invitation does not have any message
    - Guest must be active to be invited

Packets being designed: 
1) INVITE packet
    - This packet is to be sent by the inviter
    - Data: <guest> // guest is the name of the invitee
2) IN_ACK
    - Sent by invitee to server and server forwards to the inviter 

3) IN_NACK
    - Sent by invitee to the server; server forwards
    - Server should send this to the inviter in the following scenerios
        - Inviter is not part of a session
        - The guest is not active
        - The guest declined the invitation request
        - The guest is already in your own session

-------------------------------------------------------------------------------------------------------------------------
=========================================================================================================================
-------------------------------------------------------------------------------------------------------------------------

    Inviter:
    /invite <sessionID>,<guest> (INVITE PACKET : inviter -> server)
    

    ### ZAHEER ###
    Make sure guest active status is 1, make sure inviter is in sessionID (find portnumber of inviter, look_for_session_id).
    
    Server:
    Send invite to invitee (SEND TO INVITEE PACKET: server -> invitee)
    /send_invite_to_invitee <sessionID>,<inviter>

    Invite handler function done.

    ### HARRIS ####
    If we received SEND TO INVITEE packet in the receive thread,
    we assign recv_invite = True. This would notify the main thread
    to answer a yes or no to the invite. Once the main thread answers to yes or no,
    we notify the recv thread that an answer has been given. 
    
    Note: While we are deciding if we answer yes or no,
    we would also need to sleep the receive thread, and hold a queue to process tasks
    (we already have this (select statement). Just add a lock to ensure synchronization.)
    Once main thread answers yes or no, we wakeup receive thread and send 
    IN_ACK or IN_NACK right away in handle_return message. (INVITEE TO SERVER PACKET: invitee -> server)

    If IN_ACK:
    call /joinsession <sessionID> in handle_return_message
    If IN_NACK:
    We don't do anything
    
    ### ZAHEER ###
    for BOTH_CASES;
    Server forwards
    IN_ACK or IN_NACK to inviter.

    4 packets in total.


======================================================== TIMEOUT =============================================================================
3. Timeout Function

Our team implementated the timeout function on the client side.
If the client is inactive for 5 minutes, we will close the socket from the
client side, logout the client, and force it to leave any of its rooms.


===================================================== ADDITIONAL FEATURES ===================================================================================================
4. Message Choosing Function

Client may choose to message a specific subset of rooms that they are in.
With the send command:

    /send <SessionID1, SessionID2, SessionID3> <message>

5. Chat History Function

For any of the rooms that the client is in, he or she can request for the chat history from there.
With the history command:

    /history <SessionID>


The client will see it in the command prompt in this format:

This is the chat history ->
===================== 2021-04-02 21:18:45
. Room: turtle ===========================

harris -> hi!
zaheer -> what's up?
prof -> Hey you two! Stop chitchatting or I'll smack you with an apple.

The client will also be able to see the time that he or she has retrieved the chat history




    





